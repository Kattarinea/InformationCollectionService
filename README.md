# InformationCollectionService
Сервис, осуществляющий периодический сбор и выгрузку информации.

Под каждый тип информации был сформирован отдельный класс с полями, характеризующими данный объект. Например, для сбора системной информации был создан класс SysInfo. Для получения списка установленных приложений используется класс Application, включающий поля name и path.

В манифесте были прописаны разрешения на чтение сообщений, чтение контактов, разрешение на определение статуса wi-fi и сети, разрешение на взаимодействие с памятью. Так как MANAGE_EXTERNAL_STORAGE доступен только в API SDK 30 (а используется API SDK 21), в MainActivity в функции SetPermissions() было дополнительно вызвана активити с настройками разрешений на доступ ко всем файлам (ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION). Разрешение QUERY_ALL_PACKAGES необходимо для считывания всех имеющихся на телефоне приложений.

Кроме этого необходимо, чтобы приложение обладало правом на сбор статистики. Для этого также было вызвано активити с настройками (ACTION_USAGE_ACCESS_SETTINGS). 
Для того, чтобы можно было отправлять на сервер POST запросы, используя HTTP, в манифесте необходимо указать android:usesCleartextTraffic="true" и android:networkSecurityConfig= "@xml/network_security_config". 

Необходимо было обеспечить подгрузку основного функционала приложения через dex модуль. Чтобы создать файл APK, сначала скомпилируется программа для Android, а затем все ее части упакуются в один файл. Он содержит весь этот программный код (это .dex files), ресурсы, активити, сертификаты и файл манифеста.

Программы обычно записываются в Java и скомпилированы в bytecode. Затем они преобразуются из файлов Java Virtual Machine-compatible .class files в Dalvik-compatible .dex (Dalvik Executable) перед установкой на устройство. Компактный формат Dalvik Executable предназначен для систем, которые ограничены с точки зрения памяти и скорости процессора.

Сlasses.dex — исполняемый код приложения. Именно его необходимо будет скачать с удаленного ресурса при наличии доступа в интернет. Для этого при запуске приложения в методе onCreate() проверяется, не был ли этот файл уже скачан. Если нет, вызывается асинхронный метод Downloading. Т.к. скачивание довольно трудоемкий процесс, его необходимо выделять в отдельный фоновый поток. Скачивание происходит с сервиса Google Disk. Были установлены параметры скачивания: видимость, конечный каталог.

Для того, чтобы файл успел скачаться, была добавлена задержка в 10с. Далее при изменении положения Switch вызывается функция CallFunctions(), которая из dex-модуля извлекает класс Start и вызывает функцию runService().

В классе Start происходит инициализация контекста и запуск сервиса по функции startService(new Intent(this.context,Service.class)).

Так как сервер должен собирать информацию постоянно с некоторым интервалом, в методе onStartCommand() происходит запуск процесса, собирающего информацию, а после sleep(10000). Вызов CollectInformation вызывает методы класса Options, представленные на рисунке ниже, и запись собранной информации в файл.

В версиях API 21+ функция getRunningAppProcesses() возвращает только текущий процесс. Поэтому, чтобы получить весь список работающих процессов, использовался модуль UStats. Вызов printCurrentUsageStatus() обеспечивает вывод полного пула процессов.

Google значительно ограничил доступ к /proc в Android. Чтобы получить список запущенных процессов на Android, нужно использовать UsageStatsManager или получить доступ root, но не на всех устройствах работает данный менеджер. 

UStats модуль также как и UsageStatsManager требует для своей работы разрешение Manifest.permission.PACKAGE_USAGE_STATS. UStats позволяет собирать статистику по всем приложениям.

При выводе установленных приложений было добавлено условие вывода несистемных app.

После того, как вся информация была собрана по отдельным файлам, вызывается функция upload, которая подключается к серверу и отправляет ему POST-запрос. В качестве данных выступают созданные файлы. Подключение происходит по адресу http://192.168.0.107:5555. Данные считываются в buffer, после чего отправляются. getResponseCode() ожидает реакции сервера на отправленный запрос. 

Сам сервер был реализован на языке Python с использованием класса SimpleHTTPRequestHandler модуля http.server, который обслуживает файлы из текущего каталога directory, напрямую сопоставляя структуру каталогов с HTTP-запросами. Также используется CGI. CGI скрипты вызываются веб-сервером, а результат их работы отправляется на клиентский броузер. Таким образом, CGI скрипты способны выполнять любые запросы клиента на сервере и отправлять клиенту результаты запроса. В модуле CGI есть полезный класс: FieldStorage, который содержит в себе переданную в форме информацию. По сути дела, этот класс представляет из себя словарь, обладающий теми же свойствами, что и обычный питоновский словарь. Из словаря извлекаем имя файла и его данные, записывая далее в файл.
